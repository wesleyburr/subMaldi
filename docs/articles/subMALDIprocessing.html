<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Processing with subMALDI • subMALDI</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Processing with subMALDI">
<meta property="og:description" content="subMALDI">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">subMALDI</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0-0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/subMALDI_workflow.html">subMALDI: Sample Workflow</a>
    </li>
    <li>
      <a href="../articles/subMALDIprocessing.html">Processing with subMALDI</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="subMALDIprocessing_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Processing with subMALDI</h1>
                        <h4 data-toc-skip class="author">Kristen Yeh<sup>1</sup>, Sophie Castel<sup>2</sup> and Wesley Burr <sup>3</sup>
</h4>
            
      
      
      <div class="hidden name"><code>subMALDIprocessing.Rmd</code></div>

    </div>

    
    
<p><sup>1</sup> Forensic Science Program, Trent University, Peterborough, ON, Canada</p>
<p><sup>2</sup> Faculty of Science, Applied Bioscience, Ontario Tech University, Oshawa, ON, Canada</p>
<p><sup>3</sup> Faculty of Science, Mathematics, Trent University, Peterborough, ON, Canada</p>
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>In this vignette we demonstrate a pre-processing workflow for smoothing, baseline correction, and peak detection of raw, irregularly-spaced mass spectrometry data using <code>subMALDI</code>. This package is freely available from <a href="https://github.com/wesleyburr/subMaldi" class="external-link">GitHub</a> and was created using MALDI FT-ICR mass spectrometry data.</p>
<p>It is recommended that users first read through the <em>“<code>subMALDI</code> Workflow”</em> vignette before proceeding with pre-processing functions. This will assist users in understanding the basic functions included in <code>subMALDI</code>, including import, plotting, and mapping functions for comparison of multiple spectra.</p>
<div id="loading-sample-data" class="section level2">
<h2 class="hasAnchor">
<a href="#loading-sample-data" class="anchor"></a>Loading Sample Data</h2>
<p>We’ll begin this vignette by installing the package and loading a sample data set included with the package, called <code>"bsline.rda"</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st">"subMALDI"</span><span class="op">)</span>
<span class="co">#&gt; Loading required package: dplyr</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: 'dplyr'</span>
<span class="co">#&gt; The following objects are masked from 'package:stats':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     filter, lag</span>
<span class="co">#&gt; The following objects are masked from 'package:base':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     intersect, setdiff, setequal, union</span>
<span class="co">#&gt; Loading required package: tidyr</span>
<span class="co">#&gt; Loading required package: ggplot2</span>
<span class="co">#&gt; Loading required package: ggpmisc</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: 'ggpmisc'</span>
<span class="co">#&gt; The following object is masked from 'package:ggplot2':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     annotate</span>
<span class="co">#&gt; Loading required package: reshape2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: 'reshape2'</span>
<span class="co">#&gt; The following object is masked from 'package:tidyr':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     smiths</span>
<span class="co">#&gt; Loading required package: RColorBrewer</span>
<span class="co">#&gt; Warning: replacing previous import 'ggplot2::annotate' by 'ggpmisc::annotate'</span>
<span class="co">#&gt; when loading 'subMALDI'</span>
<span class="co">#&gt; Warning: replacing previous import 'dplyr::filter' by 'signal::filter' when</span>
<span class="co">#&gt; loading 'subMALDI'</span>


<span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"bsline"</span><span class="op">)</span></code></pre></div>
<p>Although most modern-day high resolution mass spectrometry instruments come with their own spectral processing software which are capable of automatic baseline correction, this software can fail, producing a spectrum with an uneven baseline.</p>
<p>Our data set <code>bsline</code> is an example of this scenario. A plot of the raw spectrum is shown below.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">bsline</span>, mass_dat <span class="op">=</span> <span class="st">"mass"</span>, spectra_cols <span class="op">=</span> <span class="st">"raw"</span>,
             colours <span class="op">=</span> <span class="st">"black"</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>, x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-3-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Observing this plot, we can clearly see the baseline of the spectrum is increasing as the x-axis increases, with the exception of a nearly Gaussian-shaped curve from the <em>m/z</em> range 700 to 1700. Before we can extract meaningful data from this raw spectrum, this irregular baseline must be corrected.</p>
<p>We will work through the pre-processing and baseline correction below, demonstrating several different methods for each processing step.</p>
<hr>
</div>
</div>
<div id="smoothing-filters" class="section level1">
<h1 class="hasAnchor">
<a href="#smoothing-filters" class="anchor"></a>Smoothing Filters</h1>
<p>As the sensitivity of high-resolution mass spectrometry instruments increases, so does the amount of detectable noise. This produces spectra which appear thicker around the baseline than at high intensity peaks, without proper spectral processing. We can see this phenomenon in our sample data set <code>bsline</code> from the <em>m/z</em> range 200 to 1700. Here, the baseline of the spectrum is very thick relative to that at higher <em>m/z</em> values and high intensity peaks.</p>
<p>In order to minimize the noise in our spectrum and create a more uniform signal throughout the analyzed <em>m/z</em> range, we will use the <code>subMALDI</code> function <code>smoothSpectrum</code>. This function offers two different filters for spectral smoothing: the Savitzky-Golay and moving average filters.</p>
<div id="savitzky-golay" class="section level2">
<h2 class="hasAnchor">
<a href="#savitzky-golay" class="anchor"></a>Savitzky-Golay</h2>
<p>The Savitzy-Golay filter is a least-squares smoothing method [1]. It performs a least squares fit of a small set of consecutive data points to a polynomial and takes the central point of the fitted polynomial curve as the output [1,2].</p>
<p>The output of a Savitzky-Golay smoothing filter is given by the following equation [1,2]: <span class="math inline">\(y[n] = \frac{\sum{A*x[n-i]}}{\sum{A}}\)</span></p>
<p>Where <code>n</code> denotes signal index and <code>k</code> indicates filter width [1]. <code>A</code> controls the polynomial order [1,2].</p>
<p>Use of <code>subMALDI</code>’s Savitzy-Golay filter is demonstrated below. When using <code>smoothSpectrum(method = "sgolay"</code>, the following arguments are required:</p>
<ul>
<li>
<code>p</code> = Filter order</li>
<li>
<code>n</code> = Filter length, must be odd</li>
<li>
<code>m</code> = Return the m-th derivative of the filter coefficients (Default = 0)</li>
<li>
<code>ts</code> = Time scaling factor (Default = 1)</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">sgolay</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/smoothSpectrum.html">smoothSpectrum</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">bsline</span>, mass_dat <span class="op">=</span> <span class="st">"mass"</span>, intensity_dat <span class="op">=</span> <span class="st">"raw"</span>,
                       method <span class="op">=</span> <span class="st">"sgolay"</span>, p <span class="op">=</span> <span class="fl">4</span>, n <span class="op">=</span> <span class="fl">7</span>, m <span class="op">=</span> <span class="fl">0</span>, ts <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>We’ll now compare our smoothed version of <code>bsline</code> to the raw spectrum by merging the intensity data into a single data frame.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">bsline</span><span class="op">$</span><span class="va">mass</span>, <span class="va">bsline</span><span class="op">$</span><span class="va">raw</span>, <span class="va">sgolay</span><span class="op">$</span><span class="va">sg</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mass"</span>, <span class="st">"Raw Spectrum"</span>, <span class="st">"Savitzky-Golay Smooth"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mass"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Raw Spectrum"</span>, <span class="st">"Savitzky-Golay Smooth"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-5-1.png" width="576" style="display: block; margin: auto;"></p>
<p>The noise of the raw spectrum has now been reduced.</p>
</div>
<div id="moving-average" class="section level2">
<h2 class="hasAnchor">
<a href="#moving-average" class="anchor"></a>Moving Average</h2>
<p>The output of a moving average smoothing filter is denoted by the following equation [1]: <span class="math inline">\(y[n] = \frac{1}{2k+1}*\sum{x[n-i]}\)</span></p>
<p>Again, <code>k</code> denotes filter width and <code>n</code> indicates signal index. The larger the filter width, the more intense the smoothing filter [1].</p>
<p>We will use the <code>"mov_avg"</code> smoothing filter on our sample data set below. When using <code>smoothSpectrum(method = "sgolay"</code>, the <code>n</code> argument, window size/filter width, is required. Since <code>bsline</code> is only extraneously noisy in the first portion of the spectrum, the value of <code>n</code> should not be too large (&lt; 10), as this will risk distorting the shape of peaks at higher <em>m/z</em> values. We will use <code>n = 7</code> in this example.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mov_avg</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/smoothSpectrum.html">smoothSpectrum</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">bsline</span>, mass_dat <span class="op">=</span> <span class="va">bsline</span><span class="op">$</span><span class="va">mass</span>, intensity_dat <span class="op">=</span> <span class="va">bsline</span><span class="op">$</span><span class="va">raw</span>,
                       method <span class="op">=</span> <span class="st">"mov_avg"</span>, n <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p>We’ll now compare our smoothed version of <code>bsline</code> to the raw spectrum by mapping the raw and smoothed intensities to a spectral data frame called <code>test</code>. The code that follows is explained in depth in the vignette <em>“<code>subMALDI</code> Workflow”.</em></p>
<p>Once our raw and smoothed spectra have been mapped to the data frame, we can remove <em>m/z</em> rows that do not correspond to any intensities in either spectra with <code><a href="../reference/rmveEmpty.html">rmveEmpty()</a></code>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/createSpecDF.html">createSpecDF</a></span><span class="op">(</span>min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span><span class="op">)</span>
<span class="va">test</span> <span class="op">&lt;-</span> <span class="fu">select</span><span class="op">(</span><span class="va">test</span>, <span class="va">full_mz</span><span class="op">)</span>
<span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/transform.html" class="external-link">transform</a></span><span class="op">(</span><span class="va">test</span>, <span class="st">"RawSpectrum"</span> <span class="op">=</span> <span class="fl">0</span>, <span class="st">"MovingAverage"</span> <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mapSpectrum.html">mapSpectrum</a></span><span class="op">(</span><span class="va">bsline</span>, massCol <span class="op">=</span> <span class="st">"mass"</span>, intenseCol <span class="op">=</span> <span class="st">"raw"</span>, 
                 colName <span class="op">=</span> <span class="st">"RawSpectrum"</span>, spec_df <span class="op">=</span> <span class="va">test</span><span class="op">)</span>
<span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mapSpectrum.html">mapSpectrum</a></span><span class="op">(</span><span class="va">mov_avg</span>, massCol <span class="op">=</span> <span class="st">"mass"</span>, intenseCol <span class="op">=</span> <span class="st">"mov_avg"</span>, 
                 colName <span class="op">=</span> <span class="st">"MovingAverage"</span>, spec_df <span class="op">=</span> <span class="va">test</span><span class="op">)</span>
<span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rmveEmpty.html">rmveEmpty</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span></code></pre></div>
<p>The raw and smoothed spectra are plotted below.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"full_mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"RawSpectrum"</span>, <span class="st">"MovingAverage"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">5</span>, intensity_scale <span class="op">=</span> <span class="st">"fixed"</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-8-1.png" width="576" style="display: block; margin: auto;"></p>
<p>The noise in the smoothed spectrum is now noticeably reduced relative to the raw spectrum.</p>
<hr>
</div>
</div>
<div id="baseline-correction-tools" class="section level1">
<h1 class="hasAnchor">
<a href="#baseline-correction-tools" class="anchor"></a>Baseline Correction Tools</h1>
<p>Baseline correction often consists of two steps. First, estimating the baseline of the spectrum, and second, subtracting the baseline from the signal [1]. <code>subMALDI</code> offers three methods for baseline estimation: local monotone minimum, linear interpolation, and LOESS curve fitting.</p>
<p>Depending on the level of noise in your data, you may choose to skip spectral smoothing and proceed to baseline correction and peak detection. <code>subMALDI</code>’s baseline correction functions are compatible with both raw and smoothed spectra.</p>
<p>In the examples that follow, we will correct the baseline of our smoothed spectra from section 2, <code>sgolay</code> and <code>mov_avg</code>, and the baseline of our raw spectrum, <code>bsline</code>, using <code><a href="../reference/baselineCorr.html">baselineCorr()</a></code>.</p>
<div id="monotone-minimum" class="section level2">
<h2 class="hasAnchor">
<a href="#monotone-minimum" class="anchor"></a>Monotone Minimum</h2>
<p>The monotone minimum method computes the difference in intensity between adjacent peaks to determine the slope of each point [1]. The baseline is then estimated as follows, moving from the leftmost to rightmost point:</p>
<ul>
<li>If slope of point <em>A</em> is greater than 0, the nearest point <em>B</em> with slope of less than 0 is located. Points in between <em>A</em> and <em>B</em> are recorded as potential peaks.</li>
<li>If slope of <em>A</em> &lt; 0, nearest point <em>B</em> with slope &gt; 0 is located. Points between <em>A</em> and <em>B</em> are recorded as valleys.</li>
</ul>
<p>Each intensity value in the spectrum is then subtracted by the intensity of the nearest valley, correcting any irregularities in the baseline of the data.</p>
<p>Use of monotone minimum method of baseline correction is demonstrated below, on the Savitzky-Golay smoothed spectrum <code>sgolay</code> from section 2.1.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mono_min</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/baselineCorr.html">baselineCorr</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">sgolay</span>, mass_dat <span class="op">=</span> <span class="st">"mass"</span>, 
                        intensity_dat <span class="op">=</span> <span class="st">"sg"</span>, method <span class="op">=</span> <span class="st">"monotone_min"</span><span class="op">)</span></code></pre></div>
<p>The smoothed and baseline corrected intensities are merged into a single data frame below, so that they can be plotted for comparison.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">sgolay</span><span class="op">$</span><span class="va">mass</span>, <span class="va">sgolay</span><span class="op">$</span><span class="va">sg</span>, <span class="va">mono_min</span><span class="op">$</span><span class="va">baseline</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"Smoothed"</span>, <span class="st">"BaselineCorrected"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Smoothed"</span>, <span class="st">"BaselineCorrected"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">5</span>, intensity_scale <span class="op">=</span> <span class="st">"fixed"</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-10-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Observing the plot above, we can see that the baseline of the spectrum now runs along the <em>x</em>-axis, and is no longer irregular.</p>
<p><strong>NOTE:</strong> Depending on the size of your data set, this function may take quite a while to run. Spectral data frames longer than 100,000 rows may take an hour to run. Methods <code>"linear"</code> and <code>"loess"</code> are capable of processing large data sets more efficiently.</p>
</div>
<div id="linear-interpolation" class="section level2">
<h2 class="hasAnchor">
<a href="#linear-interpolation" class="anchor"></a>Linear Interpolation</h2>
<p>Linear interpolation estimates the baseline of a spectrum by dividing it into small segments [1]. In each segment, the mean of the points is evaluated and recorded as a baseline predictor for that segment [1].</p>
<p>A baseline is then generated by linearly interpolating baseline predictors across all small segments [1]. In each segment, the intensity of each peak is subtracted by the intensity of the baseline predictor in that segment.</p>
<p>We will use this method of baseline correction on our <code>mov_avg</code> spectrum from section 2.2 below. When using <code><a href="../reference/baselineCorr.html">baselineCorr(method = "linear")</a></code>, the <code>n</code> argument, segment size, is required. To be consistent with previous examples, we will use <code>n = 7</code>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">linear_int</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/baselineCorr.html">baselineCorr</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">mov_avg</span>, mass_dat <span class="op">=</span> <span class="st">"mass"</span>, 
                           intensity_dat <span class="op">=</span> <span class="st">"mov_avg"</span>, method <span class="op">=</span> <span class="st">"linear"</span>, n <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p>In order to compare the smoothed and baseline-corrected spectra, we will once again merge their intensities into a single data frame. Once the data has been organized, we can plot it for comparison.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">mov_avg</span><span class="op">$</span><span class="va">mass</span>, <span class="va">mov_avg</span><span class="op">$</span><span class="va">mov_avg</span>, <span class="va">linear_int</span><span class="op">$</span><span class="va">baseline</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"Smoothed"</span>, <span class="st">"BaselineCorrected"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Smoothed"</span>, <span class="st">"BaselineCorrected"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-12-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Again, we can see the baseline now falls along the <em>x</em>-axis and is no longer irregular.</p>
</div>
<div id="loess" class="section level2">
<h2 class="hasAnchor">
<a href="#loess" class="anchor"></a>LOESS</h2>
<p>Much like the linear interpolation method, LOESS curve fitting begins by dividing a spectrum into small segments [1]. The quantile is then evaluated in each segment [1]. The baseline is estimated as follows:</p>
<ul>
<li>If the intensity of point <em>A</em> in a segment is less than the quantile, the intensity of point <em>A</em> is recorded as a baseline predictor for that point [1].</li>
<li>If the intensity of point <em>A</em> is greater than or equal to the quantile in the segment, the quantile for the segment is recorded the baseline predictor for that point [1].</li>
</ul>
<p>Local polynomial regression fitting is applied to the predictor points [1]. The baseline is then subtracted from the raw spectral signal.</p>
<p>The LOESS method of baseline correction is demonstrated below on our sample raw spectrum, <code>bsline</code>.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">loess</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/baselineCorr.html">baselineCorr</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">bsline</span>, mass_dat <span class="op">=</span> <span class="st">"mass"</span>, 
                      intensity_dat <span class="op">=</span> <span class="st">"raw"</span>, method <span class="op">=</span> <span class="st">"loess"</span><span class="op">)</span></code></pre></div>
<p>The raw and baseline corrected spectra are merged into a single data frame and plotted below.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">bsline</span><span class="op">$</span><span class="va">mass</span>, <span class="va">bsline</span><span class="op">$</span><span class="va">raw</span>, <span class="va">loess</span><span class="op">$</span><span class="va">baseline</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"RawSpectrum"</span>, <span class="st">"BaselineCorrected"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"RawSpectrum"</span>, <span class="st">"BaselineCorrected"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-14-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Once more, we see the baseline of the corrected spectrum running along the <em>x</em>-axis, with the irregularities of the raw spectral baseline removed.</p>
<hr>
</div>
</div>
<div id="peak-detection-methods" class="section level1">
<h1 class="hasAnchor">
<a href="#peak-detection-methods" class="anchor"></a>Peak Detection Methods</h1>
<p>Spectral data sets can be further processed using peak detection methods. In this step, false peak candidates are removed from a spectrum if they do not meet the criteria in the method.</p>
<p><code>subMALDI</code> offers two methods for peak detection: signal-to-noise ratio and slopes of peaks. Examples can be found below, in sections 4.1 and 4.2.</p>
<p><code>subMALDI</code> is also compatible with other R packages designed for processing mass spectra. To demonstrate this, we will use the continuous wavelet transform (CWT) algorithm from <code>MassSpecWavelet</code> [3] to baseline correct and detect peaks in <code>subMALDI</code>’s sample data. This is shown in section 4.3.</p>
<div id="signal-to-noise-snr" class="section level2">
<h2 class="hasAnchor">
<a href="#signal-to-noise-snr" class="anchor"></a>Signal-to-Noise (SNR)</h2>
<p>Each spectrum is divided into segments of size <code>n</code>. Noise is calculated as the median absolute deviation of points within each segment [1].</p>
<p>The intensity of each peak is then divided by the noise in that segment, yielding an SNR value for each peak. If the SNR value of a peak is lower than the defined <code>SNR_thresh</code>, the peak candidate is discarded [1].</p>
<p>We will perform SNR peak detection on our monotone minimum baseline corrected data set from section 3.1, <code>monotone_min</code>, below.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">snr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/peakDet.html">peakDet</a></span><span class="op">(</span><span class="va">mono_min</span>, <span class="st">"mz"</span>, <span class="st">"baseline"</span>, method <span class="op">=</span> <span class="st">"snr"</span>, 
                  n <span class="op">=</span> <span class="fl">7</span>, SNR_thresh <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></code></pre></div>
<p>As performed previously, we will merge the intensity data from the baseline corrected and peak-filtered spectra. Once the data is in a single frame, we can plot the spectra for comparison.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">mono_min</span><span class="op">$</span><span class="va">mz</span>, <span class="va">mono_min</span><span class="op">$</span><span class="va">baseline</span>, <span class="va">snr</span><span class="op">$</span><span class="va">peaks</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"Baseline"</span>, <span class="st">"Peaks"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Baseline"</span>, <span class="st">"Peaks"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-16-1.png" width="576" style="display: block; margin: auto;"></p>
<p>We can see that some peaks present in the baseline corrected spectrum are not present in the peak-filtered spectrum. These peaks did not meet the SNR criteria.</p>
</div>
<div id="slopes-of-peaks" class="section level2">
<h2 class="hasAnchor">
<a href="#slopes-of-peaks" class="anchor"></a>Slopes of Peaks</h2>
<p>This method uses the shapes of peaks to remove false peak candidates [1]. First, the left and right endpoints of each peak are identified on the baseline. Next, the slopes of each endpoint are evaluated.</p>
<p>If the either the left or right slope are less than a defined threshold, the peak candidate is discarded [1]. The threshold is defined as half of the local noise level, or half of the median absolute deviation in a window of size <code>n</code> [1].</p>
<p>We will demonstrate this method of peak detection below, using the linear interpolated data set generated in section 3.2, <code>linear_int</code>.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">slopes</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/peakDet.html">peakDet</a></span><span class="op">(</span><span class="va">linear_int</span>, <span class="st">"mz"</span>, <span class="st">"baseline"</span>, method <span class="op">=</span> <span class="st">"slopes"</span>,
                    n <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p>The filtered peaks and baseline-corrected intensities are merged and plotted below.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">linear_int</span><span class="op">$</span><span class="va">mz</span>, <span class="va">linear_int</span><span class="op">$</span><span class="va">baseline</span>, <span class="va">slopes</span><span class="op">$</span><span class="va">peaks</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"Baseline"</span>, <span class="st">"Peaks"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Baseline"</span>, <span class="st">"Peaks"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-18-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Once more, we can see the difference in peak distribution between the baseline corrected and peak-filtered spectra. Peaks that are not shown in the peak-filtered spectrum were discarded as the slopes of their endpoints failed to meet a threshold.</p>
</div>
<div id="continuous-wavelet-transform-cwt" class="section level2">
<h2 class="hasAnchor">
<a href="#continuous-wavelet-transform-cwt" class="anchor"></a>Continuous Wavelet Transform (CWT)</h2>
<p>Several other R packages are available for processing mass spectrometry data [3-5]. While these differ from <code>subMALDI</code> in their capabilities and organization, several of the functions from these packages can be used with <code>subMALDI</code>’s data structure.</p>
<p>Here we will demonstrate the compatibility of <code>subMALDI</code> with the continuous wavelet transform (CWT) algorithm included with <code>MassSpecWavelet</code>. The CWT algorithm is a more sophisticated method of pre-processing which is capable of both baseline correction and peak detection in a single step [1].</p>
<p>The package <code>MassSpecWavelet</code> is loaded below.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">MassSpecWavelet</span><span class="op">)</span>
<span class="co">#&gt; Loading required package: waveslim</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; waveslim: Wavelet Method for 1/2/3D Signals (version = 1.8.2)</span></code></pre></div>
<p>We will begin the CWT method by selecting our scales, or scaling factors. The scale factor compresses or dilates a signal.</p>
<p>When the scale factor is low, the signal is compressed, resulting in a more detailed spectrum. Conversely, when the scale factor is high, the signal is elongated and the resulting spectrum is less detailed.</p>
<p>In the continuous wavelet transform, the scaling factor is usually a vector. This allows the algorithm to compare each spectral signal to different sized wavelets for peak identification. While a wider variety of scaling factors generally results in more identified peaks, a long scaling factor vector may significantly impact the run time of the analysis.</p>
<p>In the example below, our scales have been selected to ensure maximum peak identification with minimum run time.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scales</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">40</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p><code>MassSpecWavelet</code> recognizes spectral data sets as a vector of intensity values. To match this data structure, we will grab only the intensity column of <code>bsline</code> and assign it to the variable <code>y</code>. For later use, we will also grab the <em>m/z</em> column from <code>bsline</code> and assign it to the variable <code>x</code>.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">bsline</span><span class="op">$</span><span class="va">raw</span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="va">bsline</span><span class="op">$</span><span class="va">mass</span></code></pre></div>
<p>Once our spectral data has been vectorized for use with <code>MassSpecWavelet</code>, we can generate our CWT coefficients using <code>scales</code>. This is performed using the code below.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">coeff</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MassSpecWavelet/man/cwt.html" class="external-link">cwt</a></span><span class="op">(</span><span class="va">y</span>, scales <span class="op">=</span> <span class="va">scales</span>, wavelet <span class="op">=</span> <span class="st">"mexh"</span><span class="op">)</span>
<span class="va">coeff</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">coeff</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">coeff</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">scales</span><span class="op">)</span></code></pre></div>
<p>The next step is to identify local maxima in our coefficient matrix. This is done as follows.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">localMax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MassSpecWavelet/man/getLocalMaximumCWT.html" class="external-link">getLocalMaximumCWT</a></span><span class="op">(</span><span class="va">coeff</span><span class="op">)</span> </code></pre></div>
<p>Once identified, the local maximal coefficients are used to identify ridge lines [1]. To generate each line, the local maximum coefficient is connected to its adjacent scale [1].</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ridgeList</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MassSpecWavelet/man/getRidge.html" class="external-link">getRidge</a></span><span class="op">(</span><span class="va">localMax</span><span class="op">)</span></code></pre></div>
<p>Ridge lines are then used to discard false peak candidates [1]. Criteria for exclusion are as follows: * If the length of the ridge line is smaller than a user-defined threshold, the peak is discarded. * If the width of a peak is not within a given range, it is discarded. [3]</p>
<p>We will use these lines to generate a peak index below.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">majorPeakInfo</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MassSpecWavelet/man/identifyMajorPeaks.html" class="external-link">identifyMajorPeaks</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">ridgeList</span>, <span class="va">coeff</span>, 
                                    scales <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">coeff</span><span class="op">)</span><span class="op">)</span>,
                                    SNR.Th <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>
<span class="va">peakIndex</span> <span class="op">&lt;-</span> <span class="va">majorPeakInfo</span><span class="op">$</span><span class="va">peakIndex</span></code></pre></div>
<p>Now that our peak index has been generated, we can flag unwanted peaks in our original data set for removal. We will create a new data frame containing the original <em>m/z</em> data in the first column, intensity data in the second column, and a peak index in the third column, which has been assigned a value of <code>FALSE</code>. We will call this data frame <code>peaks</code>.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">peaks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span>,<span class="st">"Peaks"</span> <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p>Using the <code>for</code> loop below, data points present in <code>peakIndex</code> are flagged as true peaks in our <code>peaks</code> data frame.</p>
<p>This is done by changing the value in the “Peaks” column from <code>FALSE</code>to <code>TRUE</code>, at rows indicated by <code>peakIndex</code>.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="va">peakIndex</span><span class="op">)</span><span class="op">{</span>
  <span class="va">peaks</span><span class="op">[</span><span class="va">i</span>, <span class="st">"Peaks"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span>
<span class="op">}</span></code></pre></div>
<p>Once all peaks are identified and false candidates are flagged for removal, we can begin to discard unwanted signals. This is performed below, by making the intensity value (“y”) 0 wherever the “Peaks” column is <code>FALSE</code>.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">peaks</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">peaks</span><span class="op">$</span><span class="va">Peaks</span> <span class="op">==</span> <span class="cn">FALSE</span><span class="op">)</span>, <span class="st">"y"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></code></pre></div>
<p>We can now remove the “Peaks” column, as our data has already been manipulated. We will do this by selecting only our <code>x</code> and <code>y</code> columns, and assigning them to a new data frame called <code>cwt</code>.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">cwt</span> <span class="op">&lt;-</span> <span class="fu">select</span><span class="op">(</span><span class="va">peaks</span>, <span class="va">x</span>, <span class="va">y</span><span class="op">)</span></code></pre></div>
<p>Finally, we will merge the raw and CWT-processed data for comparison by plotting.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">bsline</span><span class="op">$</span><span class="va">mass</span>, <span class="va">bsline</span><span class="op">$</span><span class="va">raw</span>, <span class="va">cwt</span><span class="op">$</span><span class="va">y</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">test</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"RawSpectrum"</span>, <span class="st">"CWT"</span><span class="op">)</span>

<span class="fu"><a href="../reference/plotSpectra.html">plotSpectra</a></span><span class="op">(</span>dat <span class="op">=</span> <span class="va">test</span>, mass_dat <span class="op">=</span> <span class="st">"mz"</span>, spectra_cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"RawSpectrum"</span>, <span class="st">"CWT"</span><span class="op">)</span>, min_mz <span class="op">=</span> <span class="fl">200</span>, max_mz <span class="op">=</span> <span class="fl">5000</span>,
            x_ticks <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></code></pre></div>
<p><img src="subMALDIprocessing_files/figure-html/unnamed-chunk-30-1.png" width="576" style="display: block; margin: auto;"></p>
<p>We can see that the algorithm has successfully corrected the irregular baseline in the raw spectrum, and has reduced the the amount of peaks relative to previous plots.</p>
<hr>
</div>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p>After users have completed the pre-processing pipeline on all individual raw spectra, they can now proceed with mapping spectral replicates to a single spectral data frame, as is demonstrated in the <em>“<code>subMALDI</code> Workflow”</em> vignette. These replicates can then be normalized, averaged, subtracted, and plotted using <code>subMALDI</code>’s suite of functions, or further processed or analyzed using other compatible R pacakges!</p>
<hr>
</div>
<div id="references" class="section level1">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<ol style="list-style-type: decimal">
<li>C. Yang, Z. He, W. Yu, Comparison of public peak detection algorithms for MALDI mass spectrometry data analysis, <em>BMC Bioinformatics</em>, 2009, <strong>10</strong>, 4.</li>
<li>A. Savitzky, M.J.E. Golay, Smoothing and differentiation of data by simplified least squares procedures, <em>Analytical Chemsitry</em>, 1964, <strong>36(8)</strong>, 1627-1639.</li>
<li>P. Du, W.A. Kibbe, S.M. Lin, Improved peak detection in mass spectrum by incorporating continuous wavelet transform-based pattern matching, <em>Bioinformatics</em>, 2006, <strong>22</strong>, 2059-2065.</li>
<li>S. Gibb, K. Strimmer, MALDIquant: a versatile R pacakge for the analysis of mass spectrometry data, <em>Bioinformatics</em>, 2012, <strong>28(17)</strong>, 2270-2271.</li>
<li>L. Gatto, K.S. Lilley, MSnbase - an R/Bioconductor package for isobaric tagged mass spectrometry data visualization, processing, and quantitation, <em>Bioinformatics</em>, 2012, <strong>28(2)</strong>, 288-289.</li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Sophie Castel.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link external-link">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
